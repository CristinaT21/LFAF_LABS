# Lab no. 4
## Topic: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Cristina Țărnă

----
## Objectives:
* Learn about Chomsky Normal Form (CNF).

* Get familiar with the approaches of normalizing a grammar.

* Implement a method for normalizing an input grammar by the rules of CNF.
    * The implementation needs to be encapsulated in a method with an appropriate signature (also 
  ideally in an appropriate class/type).
    * The implemented functionality needs to be executed and tested.
    * A BONUS point will be given for the student who will have unit tests that validate the functionality
  of the project.
    * Also, another BONUS point would be given if the student will make the aforementioned function to 
  accept any grammar, not only the one from the student's variant.

Variant 26

G = (VN, VT,  P, S)
VN = {S, A, B, D } 
VT = {a, b, d} 

P = { S -> aBA ,
S -> AB ,
A -> d ,
A -> dS ,
A -> AbBA ,
A -> epsilon ,
B -> a ,
B -> aS ,
B -> A ,
D -> Aba 
}
## Implementation description

### Code snippets from Grammar class:
```
    def toChomskyNormalForm(self):
        self.eliminateEpsilonProductions()
        self.eliminateUnitProductions()
        self.eliminateInaccessibleSymbols()
        self.eliminateNonproductiveSymbols()
        self.eliminateLongProductions()
```
 
## Let's dive deeper.
### First step: Eliminate epsilon productions.

Here I find all nullable symbols.

```
# Find all nullable symbols
        nullable = set()
        for state in self.P:
            if 'epsilon' in self.P[state]:
                nullable.add(state)
```
---
Then I generate new productions without nullable symbols.

```
# Generate new productions without nullable symbols
        new_productions = {}
        for state in self.P:
            new_productions[state] = []
            for production in self.P[state]:
                if production == 'epsilon':
                    continue
```

---
Then I generate all combinations of production symbols.

```
  # Generate all combinations of production symbols
                combinations = [[]]
                for symbol in production:
                    if symbol in nullable:
                        # Add both possibilities (symbol present, symbol removed)
                        new_combinations = []
                        for comb in combinations:
                            new_combinations.append(comb + [symbol])
                            new_combinations.append(comb)
                        combinations = new_combinations
                    else:
                        # Add symbol to all combinations
                        for comb in combinations:
                            comb.append(symbol)
                print("start", combinations, 'end')
                # Add new productions to new_productions dict
                for comb in combinations:
                    if comb:
                        new_production = ''.join(comb)
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Then I add new productions generated by nullable symbols.

```
  # Add new productions generated by nullable symbols
        for state in self.P:
            for production in self.P[state]:
                for symbol in nullable:
                    if symbol in production and len(production) != 1:
                        new_production = production.replace(symbol, '')
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Finally, I update grammar with new productions.
```
# Update grammar with new productions
        self.P = new_productions
```

### Second step: Eliminate any renaming.
Here I create a new dictionary with the same productions.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = productions
```

---
Here I eliminate all unit productions except loops. If a production is a unit production (from VN) , I add 
all productions of the unit state to the current state.
```
  # Eliminate all unit productions except loops
        for state in self.P.keys():
            productions = new_productions[state]
            for production in productions:
                if len(production) == 1 and production.isupper():
                    # A unit production
                    unit_state = production
                    for unit_production in new_productions[unit_state]:
                        if unit_production != state and unit_production not in new_productions[state]:
                            new_productions[state].append(unit_production)
```
---
Here I eliminate loops. If a state is in its productions, I remove it and add all other productions to the state.
```
  # Eliminate loops
        for state in self.P.keys():
            productions = new_productions[state]
            if state in productions:
                new_productions[state].remove(state)
                for unit_production in new_productions[state]:
                    if unit_production != state and unit_production not in new_productions[state]:
                        new_productions[state].append(unit_production)
```
---
Here I remove all unit productions.
 
``` 
# Remove all unit productions
        for state, productions in new_productions.items():
            new_productions[state] = [production for production in productions if
                                      len(production) > 1 or not production.isupper()]
```
---
Finally, I update the grammar with the new productions.
```
# Update the grammar with the new productions
        self.P = new_productions
```

### Third step: Eliminate inaccessible states.

First I create a set of reachable symbols and add the start symbol to it.
```
        reachable = set()
        # Add the start symbol to the set of reachable symbols
        reachable.add(self.S)
```
---
Then I iterate through the productions and add any symbols that can be reached from the start symbol.

```
        while True:
            old_size = len(reachable)

            for state, productions in self.P.items():
                if state in reachable:
                    for production in productions:
                        for symbol in production:
                            if symbol in self.VN:
                                reachable.add(symbol)
```
---
If there are no new symbols that were added to the set of reachable symbols, I break the loop.
```
            # Check if there are any new symbols that were added to the set of reachable symbols
            if len(reachable) == old_size:
                break
```
---
Then I find the set of inaccessible symbols.
```
        # Find the set of inaccessible symbols
        inaccessible = set(self.VN) - reachable
```
---
Finally, I remove the productions involving inaccessible symbols.
```
        # Remove the productions involving inaccessible symbols
        new_productions = {}
        for state, productions in self.P.items():
            if state not in inaccessible:
                new_productions[state] = []
                for production in productions:
                    if not any(symbol in inaccessible for symbol in production):
                        new_productions[state].append(production)
```
---
I update the grammar with the new set of productions and non-terminals.
```
        self.P = new_productions
        self.VN = reachable
        return Grammar(self.VN, self.VT, self.P, self.S)
```

### Fourth step: Eliminate non-productive states.
First I create a set of productive symbols and add the start symbol to it. Then I iterate through the 
productions and add any symbols that can be reached from the start symbol.
```
        productive = {self.S}
        changed = True
        while changed:
            changed = False
            for state, productions in self.P.items():
                for production in productions:
                    if all(s in productive for s in production):
                        if state not in productive:
                            productive.add(state)
                            changed = True
```
---
Then I find the set of non-productive symbols.
```
        nonproductive = set(self.VN) - productive
```
---
Finally, I remove the productions involving non-productive symbols.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = [p for p in productions if all(s not in nonproductive for s in p)]
```
---
I check if 'S' has an empty string production and remove it if it does.
```
        # Check if 'S' has an empty string production and remove it if it does
        if '' in new_productions[self.S]:
            new_productions[self.S].remove('')
```
---
I update the grammar with the new set of productions and non-terminals.
```
        return Grammar(list(productive), self.VT, new_productions, self.S)
```

### Fifth step: Eliminate long productions.

I start by sorting the grammar by the length of the productions. 
```
for state in self.P:
            self.P[state].sort(key=len)
```
Then I go through the productions and check its length.
If length is 1 nothing changes.
```
if len(production) == 1:
                    productions_copy[index] = production
```
If length is 2, I have 4 cases:
1. I check if the first variable is a terminal and the second is a variable. 
```angular2html
if production[0] in self.VT and production[1] in self.VN:
```
If it is, I check if the terminal is in the list of terminals that were changed. 
```angular2html
if production[0] in list_of_terminals_changed:
```
If it is, I add the new variable to the current production.
```angular2html
productions_copy[index] = (terminal_and_variable[production[0]], production[1])
```
 If the terminal is not in the list of terminals that were changed, I create a new variable for that terminal
 and I add it to the list of terminals that were changed. I add the new variable to the current production. 
 
```angular2html
  var1 = variables.pop(0)  # removes the first variable from the list
  new_var = new_grammar.getNewVariable()
  new_grammar.VN.add(new_var)
  new_grammar.P[new_var] = var1
  list_of_terminals_changed.append(var1)
  terminal_and_variable[var1] = new_var
  variables.insert(0, new_var)
  productions_copy[index] = (tuple(variables))
```
2. If the first element is a variable and second is a terminal
```angular2html
check if the first variable is a variable and the second is a terminal
                        elif production[0] in self.VN and production[1] in self.VT:
```
If it is, I check if the terminal is in the list of terminals that were changed. 
```angular2html 
if production[1] in list_of_terminals_changed:
```
If it is, I add the new variable to the current production.
```angular2html
productions_copy[index] = (production[0], terminal_and_variable[production[1]])
```
 If the terminal is not in the list of terminals that were changed, I create a new variable for that terminal
 and I add it to the list of terminals that were changed. I add the new variable to the current production. 
```angular2html 
  var1 = variables.pop(0)  # removes the first variable from the list
  new_var = new_grammar.getNewVariable()
  new_grammar.VN.add(new_var)
  new_grammar.P[new_var] = var1
  list_of_terminals_changed.append(var1)
  terminal_and_variable[var1] = new_var
  variables.insert(0, new_var)
  productions_copy[index] = (tuple(variables))
```
3. If the first element is a terminal and second is a terminal. If it is, I check if the first terminal is in the list
of terminals that were changed. If it is, I check if the second terminal is in the list of terminals that were changed.
If it is, I add the new variable to the current production. If it is not, I create a new variable for that terminal and
I add it to the list of terminals that were changed. I add the new variable to the current production. If the first 
terminal is not in the list of terminals that were changed, I create a new variable for that terminal and I add it to 
the list of terminals that were changed. I add the new variable to the current production. If the second terminal is in
the list of terminals that were changed, I add the new variable to the current production. If it is not, I create a new 
variable for that terminal and I add it to the list of terminals that were changed. I add the new variable to the 
current production. 
```angular2html
  elif production[0] in self.VT and production[1] in self.VT:
    if production[0] in list_of_terminals_changed and production[1] in \
            list_of_terminals_changed:
        new_grammar.P[index] = [
            (terminal_and_variable[production[0]], terminal_and_variable[production[1]])]
        productions_copy[index] = (new_grammar.P[index])
    elif production[0] in list_of_terminals_changed and production[1] not in \
            list_of_terminals_changed:
        var2 = variables.pop(1)
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = var2
        list_of_terminals_changed.append(var2)
        variables.insert(0, new_var)
        new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
        productions_copy[index] = (tuple(variables))
    elif production[0] not in list_of_terminals_changed and production[1] in \
            list_of_terminals_changed:
        var1 = variables.pop(0)
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = var1
        list_of_terminals_changed.append(var1)
        variables.insert(0, new_var)
        new_grammar.P[index] = [(production[0], terminal_and_variable[production[1]])]
        productions_copy[index] = (tuple(variables))
    else:
        var1 = variables.pop(0)
        var2 = variables.pop(0)  # removes the second variable from the list
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = [(var1, var2)]
        variables.insert(0, new_var)  # inserts the new variable at the beginning
        # adds a new production that uses the current state and the remaining variables
        productions_copy[index] = (tuple(variables))
```
4. If the first element is a variable and second is a variable
 I add it as it is to the current production.
```angular2html
elif production[0] in self.VN and production[1] in self.VN:
                            productions_copy[index] = (production)
```
Then I continue with the case when the length of the production is more than 2. 
I take the first two variables from the production to work with them.
```angular2html
while len(variables) > 2:
  var1 = variables.pop(0)  # removes the first variable from the list
  var2 = variables.pop(0)  # removes the second variable from the list
```
First I check if the first variable(var1) is a terminal 
* if the first terminal is changed (in list_of_terminals_changed)
  * check if var2 is a variable
    * check if a variable for var1(changed) and var2 exists
      * if it exists, add it to the current production
      * if it does not exist, create a new variable for var1 and var2 and add it to the current production
  * check if var2 is a terminal
    * if var2 in list_of_terminals_changed
      * check if a variable for var1(changed) and var2(changed) exists
         * if it exists, add it to the current production
         * if it does not exist, create a new variable for var1 and var2 and add it to the current production
    * if var2 not in list_of_terminals_changed
      * change var2
        * create a new variable for var1(changed) and var2(changed) and add it to the current production
* if the first terminal is not changed (not in list_of_terminals_changed)
     * change var1
     * check if var2 is a variable
       * create a new variable for var1 and var2 and add it to the current production
       (if var1 was not changed then there was no combination of var1 and var2)  
     * check if var2 is a terminal
       * if var2 in list_of_terminals_changed
         * create a new variable for var1(changed) and var2(changed) and add it to the current production
       * if var2 not in list_of_terminals_changed
         * change var2
           * create a new variable for var1(changed) and var2(changed) and add it to the current production
Second I check if the first variable(var1) is a variable
* if var2 is a variable
  * check if a variable for var1 and var2 exists
    * if it exists, add it to the current production
    * if it does not exist, create a new variable for var1 and var2 and add it to the current production
* if var2 is a terminal
  * if var2 in list_of_terminals_changed
    * check if a variable for var1 and var2(changed) exists
      * if it exists, add it to the current production
      * if it does not exist, create a new variable for var1 and var2(changed) and add it to the current production
  * if var2 not in list_of_terminals_changed
    * change var2
      * create a new variable for var1 and var2(changed) and add it to the current production

I won't paste the whole code because it is a lot.

This is the way I check if a variable for var1 and var2 exists:
```angular2html
keys = [k for k, v in new_grammar.P.items() if v == [terminal_and_variable[var1], var2]]
if keys != []:
    key = ''.join(keys)
    variables.insert(0, key)
    productions_copy[index] = key
    gata = True
else:
    new_var = new_grammar.getNewVariable()
    new_grammar.VN.add(new_var)
    new_grammar.P[new_var] = [terminal_and_variable[var1], var2]
    variables.insert(0, new_var)
    productions_copy[index] = (tuple(variables))
    gata = True
```
## Main class
```angular2html 
 P1 = {
          "S": ["aBA", "AB"],
          "A": ["d", "dS", "AbBA", "epsilon"],
          "B": ["a", "aS", "A"],
          "D": ["Aba"]
      }
      g: Grammar = Grammar(VN=["S", "A", "B", "D"], VT=["a", "b", "d"], P=P1, S='S')
      opt_no = int(input("Enter 1 to see the final result or 2 to see each step: "))
      if opt_no == 1:
          print('\nGrammar in Chomsky Normal Form:')
          g.toChomskyNormalForm()
          print(g.P)
      elif opt_no == 2:
          print('See each step:')
          g.eliminateEpsilonProductions()
          print("Eliminate Epsilon Productions", g.P)
          g.eliminateUnitProductions()
          print("Eliminate Unit Productions", g.P)
          g.eliminateInaccessibleSymbols()
          print('Eliminate Inaccessible Symbols', g.P)
          g.eliminateNonproductiveSymbols()
          print('Eliminate Nonproductive Symbols', g.P)
          g.eliminateLongProductions()
          print('Eliminate Long Productions', g.P)
```


## Results
Enter 1 to see the final result or 2 to see each step: 2

See each step:

Eliminate Epsilon Productions {'S': ['aBA', 'aB', 'AB', 'B'], 'A': ['d', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'B': ['a', 'aS', 'A'], 'D': ['Aba', 'ba']}

Eliminate Unit Productions {'S': ['aBA', 'aB', 'AB', 'a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'A': ['d', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'B': ['a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'D': ['Aba', 'ba']}

Eliminate Inaccessible Symbols {'S': ['aBA', 'aB', 'AB', 'a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'A': ['d', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'B': ['a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB']}

Eliminate Nonproductive Symbols {'S': ['aBA', 'aB', 'AB', 'a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'A': ['d', 'dS', 'AbBA', 'AbB', 'bBA', 'bB'], 'B': ['a', 'aS', 'd', 'dS', 'AbBA', 'AbB', 'bBA', 'bB']}

Eliminate Long Productions {'S': ['a', 'd', ('X1', 'B'), 'AB', ('X1', 'S'), ('X2', 'S'), ('X3', 'B'), ('X4', 'A'), ('X5', 'B'), ('X6', 'A'), ('X7', 'A')], 'A': ['d', ('X2', 'S'), ('X3', 'B'), ('X5', 'B'), ('X6', 'A'), ('X7', 'A')], 'B': ['a', 'd', ('X1', 'S'), ('X2', 'S'), ('X3', 'B'), ('X5', 'B'), ('X6', 'A'), ('X7', 'A')]}
