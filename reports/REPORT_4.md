# Lab no. 4
## Topic: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Cristina Țărnă

----
## Objectives:
* Learn about Chomsky Normal Form (CNF).

* Get familiar with the approaches of normalizing a grammar.

* Implement a method for normalizing an input grammar by the rules of CNF.
    * The implementation needs to be encapsulated in a method with an appropriate signature (also 
  ideally in an appropriate class/type).
    * The implemented functionality needs to be executed and tested.
    * A BONUS point will be given for the student who will have unit tests that validate the functionality
  of the project.
    * Also, another BONUS point would be given if the student will make the aforementioned function to 
  accept any grammar, not only the one from the student's variant.

Variant 26

1. Eliminate epsilon productions.
2. Eliminate any renaming.
3. Eliminate inaccessible symbols.
4. Eliminate the non-productive symbols.
5. Obtain the Chomsky Normal Form.

G = (VN, VT,  P, S)
VN = {S, A, B, D } 
VT = {a, b, d} 

P = { S -> aBA ,
S -> AB ,
A -> d ,
A -> dS ,
A -> AbBA ,
A -> epsilon ,
B -> a ,
B -> aS ,
B -> A ,
D -> Aba 
}
## Implementation description

### Code snippets from Grammar class:
```
    def toChomskyNormalForm(self):
        self.eliminateEpsilonProductions()
        self.eliminateUnitProductions()
        self.eliminateInaccessibleSymbols()
        self.eliminateNonproductiveSymbols()
        self.eliminateLongProductions()
```
 
## Let's dive deeper.
### First step: Eliminate epsilon productions.
```
    def eliminateEpsilonProductions(self):
        # Find all nullable symbols
        nullable = set()
        for state in self.P:
            if 'epsilon' in self.P[state]:
                nullable.add(state)

        # Generate new productions without nullable symbols
        new_productions = {}
        for state in self.P:
            new_productions[state] = []
            for production in self.P[state]:
                if production == 'epsilon':
                    continue

                # Generate all combinations of production symbols
                combinations = [[]]
                for symbol in production:
                    if symbol in nullable:
                        # Add both possibilities (symbol present, symbol removed)
                        new_combinations = []
                        for comb in combinations:
                            new_combinations.append(comb + [symbol])
                            new_combinations.append(comb)
                        combinations = new_combinations
                    else:
                        # Add symbol to all combinations
                        for comb in combinations:
                            comb.append(symbol)
                print("start", combinations, 'end')
                # Add new productions to new_productions dict
                for comb in combinations:
                    if comb:
                        new_production = ''.join(comb)
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)

        # Add new productions generated by nullable symbols
        for state in self.P:
            for production in self.P[state]:
                for symbol in nullable:
                    if symbol in production and len(production) != 1:
                        new_production = production.replace(symbol, '')
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)

        # Update grammar with new productions
        self.P = new_productions
```
---
Here I find all nullable symbols.

```
# Find all nullable symbols
        nullable = set()
        for state in self.P:
            if 'epsilon' in self.P[state]:
                nullable.add(state)
```
---
Then I generate new productions without nullable symbols.

```
# Generate new productions without nullable symbols
        new_productions = {}
        for state in self.P:
            new_productions[state] = []
            for production in self.P[state]:
                if production == 'epsilon':
                    continue
```

---
Then I generate all combinations of production symbols.

```
  # Generate all combinations of production symbols
                combinations = [[]]
                for symbol in production:
                    if symbol in nullable:
                        # Add both possibilities (symbol present, symbol removed)
                        new_combinations = []
                        for comb in combinations:
                            new_combinations.append(comb + [symbol])
                            new_combinations.append(comb)
                        combinations = new_combinations
                    else:
                        # Add symbol to all combinations
                        for comb in combinations:
                            comb.append(symbol)
                print("start", combinations, 'end')
                # Add new productions to new_productions dict
                for comb in combinations:
                    if comb:
                        new_production = ''.join(comb)
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Then I add new productions generated by nullable symbols.

```
  # Add new productions generated by nullable symbols
        for state in self.P:
            for production in self.P[state]:
                for symbol in nullable:
                    if symbol in production and len(production) != 1:
                        new_production = production.replace(symbol, '')
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Finally, I update grammar with new productions.
```
# Update grammar with new productions
        self.P = new_productions
```

### Second step: Eliminate any renaming.
```
        def eliminateUnitProductions(self):
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = productions
        # Eliminate all unit productions except loops
        for state in self.P.keys():
            productions = new_productions[state]
            for production in productions:
                if len(production) == 1 and production.isupper():
                    # A unit production
                    unit_state = production
                    for unit_production in new_productions[unit_state]:
                        if unit_production != state and unit_production not in new_productions[state]:
                            new_productions[state].append(unit_production)
        # Eliminate loops
        for state in self.P.keys():
            productions = new_productions[state]
            if state in productions:
                new_productions[state].remove(state)
                for unit_production in new_productions[state]:
                    if unit_production != state and unit_production not in new_productions[state]:
                        new_productions[state].append(unit_production)
        # Remove all unit productions
        for state, productions in new_productions.items():
            new_productions[state] = [production for production in productions if
                                      len(production) > 1 or not production.isupper()]
        self.P = new_productions
```
---
Here I create a new dictionary with the same productions.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = productions
```

---
Here I eliminate all unit productions except loops. If a production is a unit production (from VN) , I add 
all productions of the unit state to the current state.
```
  # Eliminate all unit productions except loops
        for state in self.P.keys():
            productions = new_productions[state]
            for production in productions:
                if len(production) == 1 and production.isupper():
                    # A unit production
                    unit_state = production
                    for unit_production in new_productions[unit_state]:
                        if unit_production != state and unit_production not in new_productions[state]:
                            new_productions[state].append(unit_production)
```
---
Here I eliminate loops. If a state is in its productions, I remove it and add all other productions to the state.
```
  # Eliminate loops
        for state in self.P.keys():
            productions = new_productions[state]
            if state in productions:
                new_productions[state].remove(state)
                for unit_production in new_productions[state]:
                    if unit_production != state and unit_production not in new_productions[state]:
                        new_productions[state].append(unit_production)
```
---
Here I remove all unit productions.
 
``` 
# Remove all unit productions
        for state, productions in new_productions.items():
            new_productions[state] = [production for production in productions if
                                      len(production) > 1 or not production.isupper()]
```
---
Finally, I update the grammar with the new productions.
```
# Update the grammar with the new productions
        self.P = new_productions
```

### Third step: Eliminate inaccessible states.
```
        reachable = set()
        # Add the start symbol to the set of reachable symbols
        reachable.add(self.S)

        # Iterate through the productions and add any symbols that can be reached
        # from the start symbol
        while True:
            old_size = len(reachable)

            for state, productions in self.P.items():
                if state in reachable:
                    for production in productions:
                        for symbol in production:
                            if symbol in self.VN:
                                reachable.add(symbol)

            # Check if there are any new symbols that were added to the set of reachable symbols
            if len(reachable) == old_size:
                break

        # Find the set of inaccessible symbols
        inaccessible = set(self.VN) - reachable

        # Remove the productions involving inaccessible symbols
        new_productions = {}
        for state, productions in self.P.items():
            if state not in inaccessible:
                new_productions[state] = []
                for production in productions:
                    if not any(symbol in inaccessible for symbol in production):
                        new_productions[state].append(production)

        # Update the grammar with the new set of productions and non-terminals
        self.P = new_productions
        self.VN = reachable

        return Grammar(self.VN, self.VT, self.P, self.S)
```

---
First I create a set of reachable symbols and add the start symbol to it.
```
        reachable = set()
        # Add the start symbol to the set of reachable symbols
        reachable.add(self.S)
```
---
Then I iterate through the productions and add any symbols that can be reached from the start symbol.

```
        while True:
            old_size = len(reachable)

            for state, productions in self.P.items():
                if state in reachable:
                    for production in productions:
                        for symbol in production:
                            if symbol in self.VN:
                                reachable.add(symbol)
```
---
If there are no new symbols that were added to the set of reachable symbols, I break the loop.
```
            # Check if there are any new symbols that were added to the set of reachable symbols
            if len(reachable) == old_size:
                break
```
---
Then I find the set of inaccessible symbols.
```
        # Find the set of inaccessible symbols
        inaccessible = set(self.VN) - reachable
```
---
Finally, I remove the productions involving inaccessible symbols.
```
        # Remove the productions involving inaccessible symbols
        new_productions = {}
        for state, productions in self.P.items():
            if state not in inaccessible:
                new_productions[state] = []
                for production in productions:
                    if not any(symbol in inaccessible for symbol in production):
                        new_productions[state].append(production)
```
---
I update the grammar with the new set of productions and non-terminals.
```
        self.P = new_productions
        self.VN = reachable

        return Grammar(self.VN, self.VT, self.P, self.S)
```

### Fourth step: Eliminate non-productive states.
```
ef eliminateNonproductiveSymbols(self):
        productive = {self.S}
        changed = True
        while changed:
            changed = False
            for state, productions in self.P.items():
                for production in productions:
                    if all(s in productive for s in production):
                        if state not in productive:
                            productive.add(state)
                            changed = True
        nonproductive = set(self.VN) - productive
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = [p for p in productions if all(s not in nonproductive for s in p)]
        # Check if 'S' has an empty string production and remove it if it does
        if '' in new_productions[self.S]:
            new_productions[self.S].remove('')
        return Grammar(list(productive), self.VT, new_productions, self.S)
```
---
First I create a set of productive symbols and add the start symbol to it. Then I iterate through the 
productions and add any symbols that can be reached from the start symbol.
```
        productive = {self.S}
        changed = True
        while changed:
            changed = False
            for state, productions in self.P.items():
                for production in productions:
                    if all(s in productive for s in production):
                        if state not in productive:
                            productive.add(state)
                            changed = True
```
---
Then I find the set of non-productive symbols.
```
        nonproductive = set(self.VN) - productive
```
---
Finally, I remove the productions involving non-productive symbols.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = [p for p in productions if all(s not in nonproductive for s in p)]
```
---
I check if 'S' has an empty string production and remove it if it does.
```
        # Check if 'S' has an empty string production and remove it if it does
        if '' in new_productions[self.S]:
            new_productions[self.S].remove('')
```
---
I update the grammar with the new set of productions and non-terminals.
```
        return Grammar(list(productive), self.VT, new_productions, self.S)
```

### Fifth step: Eliminate long productions.
```
       def eliminateLongProductions(self):
        for state in self.P:
            self.P[state].sort(key=len)
        new_P = self.P.copy()
        new_VN = self.VN.copy()
        new_VT = self.VT.copy()
        new_S = self.S
        new_grammar = Grammar(new_VN, new_VT, new_P, new_S)
        list_of_terminals_changed = []
        terminal_and_variable = {}
        for state in self.P:
            productions = self.P[state]
            productions_copy = self.P[state]
            for index, production in enumerate(productions):
                if len(production) == 1:
                    productions_copy[index] = production
                elif len(production) == 2:
                    variables = list(production)
                    if len(variables) == 2:
                        # check if the first variable is a terminal and the second is a variable
                        if production[0] in self.VT and production[1] in self.VN:
                            # check if the terminal has already been changed
                            if production[0] in list_of_terminals_changed:
                                productions_copy[index] = (terminal_and_variable[production[0]], production[1])
                            # if the terminal has not been changed, change it
                            else:
                                var1 = variables.pop(0)  # removes the first variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = var1
                                list_of_terminals_changed.append(var1)
                                terminal_and_variable[var1] = new_var
                                variables.insert(0, new_var)
                                productions_copy[index] = (tuple(variables))
                        # check if the first variable is a variable and the second is a terminal
                        elif production[0] in self.VN and production[1] in self.VT:
                            # check if the terminal has already been changed
                            if production[1] in list_of_terminals_changed:
                                productions[index] = (production[0], terminal_and_variable[production[1]])
                            else:
                                var2 = variables.pop(1)  # removes the second variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = var2
                                list_of_terminals_changed.append(var2)
                                variables.insert(0, new_var)
                                productions_copy[index] = (tuple(variables))
                        elif production[0] in self.VT and production[1] in self.VT:
                            if production[0] in list_of_terminals_changed and production[1] in \
                                    list_of_terminals_changed:
                                new_grammar.P[index] = [
                                    (terminal_and_variable[production[0]], terminal_and_variable[production[1]])]
                                productions_copy[index] = (new_grammar.P[index])
                            elif production[0] in list_of_terminals_changed and production[1] not in \
                                    list_of_terminals_changed:
                                var2 = variables.pop(1)
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = var2
                                list_of_terminals_changed.append(var2)
                                variables.insert(0, new_var)
                                new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
                                productions_copy[index] = (tuple(variables))
                            elif production[0] not in list_of_terminals_changed and production[1] in \
                                    list_of_terminals_changed:
                                var1 = variables.pop(0)
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = var1
                                list_of_terminals_changed.append(var1)
                                variables.insert(0, new_var)
                                new_grammar.P[index] = [(production[0], terminal_and_variable[production[1]])]
                                productions_copy[index] = (tuple(variables))
                            else:
                                var1 = variables.pop(0)
                                var2 = variables.pop(0)  # removes the second variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1, var2)]
                                variables.insert(0, new_var)  # inserts the new variable at the beginning
                                # adds a new production that uses the current state and the remaining variables
                                productions_copy[index] = (tuple(variables))

                        elif production[0] in self.VN and production[1] in self.VN:
                            productions_copy[index] = (production)
                    else:
                        break
                elif len(production) > 2:
                    # Replace with new variables and productions
                    variables = list(production)
                    while len(variables) > 2:
                        var1 = variables.pop(0)  # removes the first variable from the list
                        var2 = variables.pop(0)  # removes the second variable from the list
                        # if var1 is terminal
                        if var1 in new_grammar.VT:
                            # if var1 is a terminal and in list of terminals changed
                            if var1 in list_of_terminals_changed:
                                gata = False
                                # for var1 terminal in list and var2 variable
                                if var2 in new_grammar.VN:
                                    for i in range(len(new_grammar.P)):
                                        if gata == False:
                                            keys = [k for k, v in new_grammar.P.items() if
                                                    v == [terminal_and_variable[var1], var2]]
                                            if keys != []:
                                                key = ''.join(keys)
                                                variables.insert(0, key)
                                                productions_copy[index] = key
                                                gata = True
                                            # if [terminal_and_variable[var1], var2] != list(new_grammar.P)[i]:
                                            else:
                                                new_var = new_grammar.getNewVariable()
                                                new_grammar.VN.add(new_var)
                                                new_grammar.P[new_var] = [terminal_and_variable[var1], var2]
                                                variables.insert(0, new_var)
                                                productions_copy[index] = (tuple(variables))
                                                gata = True
                                # for var1 terminal in list and var2 terminal
                                elif var2 in new_grammar.VT:
                                    if var2 in list_of_terminals_changed:
                                        gata = False
                                        for i in range(len(new_grammar.P)):
                                            if gata == False:
                                                keys = [k for k, v in new_grammar.P.items() if
                                                        v == [terminal_and_variable[var1], terminal_and_variable[var2]]]
                                                if keys != []:
                                                    key = ''.join(keys)
                                                    variables.insert(0, key)
                                                    productions_copy[index] = key
                                                    gata = True

                                                else:
                                                    new_var = new_grammar.getNewVariable()
                                                    new_grammar.VN.add(new_var)
                                                    new_grammar.P[new_var] = [terminal_and_variable[var1],
                                                                              terminal_and_variable[var2]]
                                                    variables.insert(0, new_var)
                                                    productions_copy[index] = (tuple(variables))
                                                    gata = True
                                    elif var2 not in list_of_terminals_changed:
                                        # change var2 with new variable
                                        new_var2 = new_grammar.getNewVariable()
                                        new_grammar.VN.add(new_var2)
                                        new_grammar.P[new_var2] = var2
                                        list_of_terminals_changed.append(var2)
                                        terminal_and_variable[var2] = new_var2
                                        variables.insert(0, new_var2)
                                        productions_copy[index] = (tuple(variables))
                                        # add new production of var1 and new var2
                                        new_var = new_grammar.getNewVariable()
                                        new_grammar.VN.add(new_var)
                                        new_grammar.P[new_var] = [terminal_and_variable[var1], 
                                                                  terminal_and_variable[var2]]
                                        variables.insert(0, new_var)
                                        productions_copy[index] = (tuple(variables))
                                        gata = True
                            #
                            # for var1 terminal not in list
                            elif var1 not in list_of_terminals_changed:
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = var1
                                list_of_terminals_changed.append(var1)
                                terminal_and_variable[var1] = new_var
                                variables.insert(0, new_var)
                                productions_copy[index] = (tuple(variables))
                                gata = False
                                # for var1 terminal not in list and var2 variable
                                if var2 in new_grammar.VN:
                                    for i in range(len(new_grammar.P)):
                                        if gata == False:
                                            # if var1 was not changed then there was no combination of var1 and var2
                                            new_var = new_grammar.getNewVariable()
                                            new_grammar.VN.add(new_var)
                                            new_grammar.P[new_var] = [terminal_and_variable[var1], var2]
                                            variables.insert(0, new_var)
                                            productions_copy[index] = (tuple(variables))
                                            gata = True
                                # for var1 terminal not in list and var2 terminal
                                elif var2 in new_grammar.VT:
                                    # var2 was changed
                                    if var2 in list_of_terminals_changed:
                                        gata = False
                                        for i in range(len(new_grammar.P)):
                                            if gata == False:
                                                keys = [k for k, v in new_grammar.P.items() if
                                                        v == [terminal_and_variable[var1], terminal_and_variable[var2]]]
                                                if keys != []:
                                                    key = ''.join(keys)
                                                    variables.insert(0, key)
                                                    productions_copy[index] = key
                                                    gata = True

                                                else:
                                                    new_var = new_grammar.getNewVariable()
                                                    new_grammar.VN.add(new_var)
                                                    new_grammar.P[new_var] = [terminal_and_variable[var1],
                                                                              terminal_and_variable[var2]]
                                                    variables.insert(0, new_var)
                                                    productions_copy[index] = (tuple(variables))
                                                    gata = True
                                    elif var2 not in list_of_terminals_changed:
                                        # change var2 with new variable
                                        new_var2 = new_grammar.getNewVariable()
                                        new_grammar.VN.add(new_var2)
                                        new_grammar.P[new_var2] = var2
                                        list_of_terminals_changed.append(var2)
                                        terminal_and_variable[var2] = new_var2
                                        variables.insert(0, new_var2)
                                        productions_copy[index] = (tuple(variables))
                                        # add new production of var1 and new var2
                                        new_var = new_grammar.getNewVariable()
                                        new_grammar.VN.add(new_var)
                                        new_grammar.P[new_var] = [terminal_and_variable[var1], 
                                                                  terminal_and_variable[var2]]
                                        variables.insert(0, new_var)
                                        productions_copy[index] = (tuple(variables))
                                        gata = True

                        if var1 in new_grammar.VN: # for var1 variable
                            gata = False
                            # for var1 variable and var2 variable
                            if var2 in new_grammar.VN:
                                for i in range(len(new_grammar.P)):
                                    if gata == False:
                                        keys = [k for k, v in new_grammar.P.items() if
                                                v == [var1, var2]]
                                        if keys != []:
                                            key = ''.join(keys)
                                            variables.insert(0, key)
                                            productions_copy[index] = key
                                            gata = True

                                        else:
                                            new_var = new_grammar.getNewVariable()
                                            new_grammar.VN.add(new_var)
                                            new_grammar.P[new_var] = [var1, var2]
                                            variables.insert(0, new_var)
                                            productions_copy[index] = (tuple(variables))
                                            gata = True
                            if var2 in new_grammar.VT:
                                if var2 in list_of_terminals_changed:
                                    gata = False
                                    for i in range(len(new_grammar.P)):
                                        if gata == False:
                                            keys = [k for k, v in new_grammar.P.items() if v == [var1, terminal_and_variable[var2]]]
                                            if keys != []:
                                                key = ''.join(keys)
                                                variables.insert(0, key)
                                                productions_copy[index] = key
                                                gata = True
                                            else:
                                                if gata == False:
                                                    new_var = new_grammar.getNewVariable()
                                                    new_grammar.VN.add(new_var)
                                                    new_grammar.P[new_var] = [var1, terminal_and_variable[var2]]
                                                    variables.insert(0, new_var)
                                                    productions_copy[index] = (tuple(variables))
                                                    gata = True
                                elif var2 not in list_of_terminals_changed:
                                    # change var2 with new variable
                                    new_var2 = new_grammar.getNewVariable()
                                    new_grammar.VN.add(new_var2)
                                    new_grammar.P[new_var2] = var2
                                    list_of_terminals_changed.append(var2)
                                    terminal_and_variable[var2] = new_var2
                                    variables.insert(0, new_var2)
                                    productions_copy[index] = (tuple(variables))
                                    # add new production of var1 and new var2
                                    new_var = new_grammar.getNewVariable()
                                    new_grammar.VN.add(new_var)
                                    new_grammar.P[new_var] = [var1, new_var2]
                                    variables.insert(0, new_var)
                                    productions_copy[index] = (tuple(variables))
                                    gata = True

                    # adds a new production that uses the current state and the remaining variables
                    productions_copy[index] = (tuple(variables))
                else:
                    productions_copy[index] = production  # add the production as is
            new_grammar.P[state] = productions_copy  # Update the grammar with the new productions
        return new_grammar
```
I start by sorting the grammar by the length of the productions. 
```
for state in self.P:
            self.P[state].sort(key=len)
```
Then I go through the productions and check its length.
If length is 1 nothing changes.
```
if len(production) == 1:
                    productions_copy[index] = production
```
If length is 2, I have 4 cases:
1. I check if the first variable is a terminal and the second is a variable. 
```angular2html
if production[0] in self.VT and production[1] in self.VN:
```
If it is, I check if the terminal is in the list of terminals that were changed. 
```angular2html
if production[0] in list_of_terminals_changed:
```
If it is, I add the new variable to the current production.
```angular2html
productions_copy[index] = (terminal_and_variable[production[0]], production[1])
```
 If the terminal is not in the list of terminals that were changed, I create a new variable for that terminal
 and I add it to the list of terminals that were changed. I add the new variable to the current production. 
 
```angular2html
  var1 = variables.pop(0)  # removes the first variable from the list
  new_var = new_grammar.getNewVariable()
  new_grammar.VN.add(new_var)
  new_grammar.P[new_var] = var1
  list_of_terminals_changed.append(var1)
  terminal_and_variable[var1] = new_var
  variables.insert(0, new_var)
  productions_copy[index] = (tuple(variables))
```
2. If the first element is a variable and second is a terminal
```angular2html
check if the first variable is a variable and the second is a terminal
                        elif production[0] in self.VN and production[1] in self.VT:
```
If it is, I check if the terminal is in the list of terminals that were changed. 
```angular2html 
if production[1] in list_of_terminals_changed:
```
If it is, I add the new variable to the current production.
```angular2html
productions_copy[index] = (production[0], terminal_and_variable[production[1]])
```
 If the terminal is not in the list of terminals that were changed, I create a new variable for that terminal
 and I add it to the list of terminals that were changed. I add the new variable to the current production. 
```angular2html 
var1 = variables.pop(0)  # removes the first variable from the list
  new_var = new_grammar.getNewVariable()
  new_grammar.VN.add(new_var)
  new_grammar.P[new_var] = var1
  list_of_terminals_changed.append(var1)
  terminal_and_variable[var1] = new_var
  variables.insert(0, new_var)
  productions_copy[index] = (tuple(variables))
```
3. If the first element is a terminal and second is a terminal. If it is, I check if the first terminal is in the list
of terminals that were changed. If it is, I check if the second terminal is in the list of terminals that were changed.
If it is, I add the new variable to the current production. If it is not, I create a new variable for that terminal and
I add it to the list of terminals that were changed. I add the new variable to the current production. If the first 
terminal is not in the list of terminals that were changed, I create a new variable for that terminal and I add it to 
the list of terminals that were changed. I add the new variable to the current production. If the second terminal is in
the list of terminals that were changed, I add the new variable to the current production. If it is not, I create a new 
variable for that terminal and I add it to the list of terminals that were changed. I add the new variable to the 
current production. 
```angular2html
  elif production[0] in self.VT and production[1] in self.VT:
    if production[0] in list_of_terminals_changed and production[1] in \
            list_of_terminals_changed:
        new_grammar.P[index] = [
            (terminal_and_variable[production[0]], terminal_and_variable[production[1]])]
        productions_copy[index] = (new_grammar.P[index])
    elif production[0] in list_of_terminals_changed and production[1] not in \
            list_of_terminals_changed:
        var2 = variables.pop(1)
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = var2
        list_of_terminals_changed.append(var2)
        variables.insert(0, new_var)
        new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
        productions_copy[index] = (tuple(variables))
    elif production[0] not in list_of_terminals_changed and production[1] in \
            list_of_terminals_changed:
        var1 = variables.pop(0)
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = var1
        list_of_terminals_changed.append(var1)
        variables.insert(0, new_var)
        new_grammar.P[index] = [(production[0], terminal_and_variable[production[1]])]
        productions_copy[index] = (tuple(variables))
    else:
        var1 = variables.pop(0)
        var2 = variables.pop(0)  # removes the second variable from the list
        new_var = new_grammar.getNewVariable()
        new_grammar.VN.add(new_var)
        new_grammar.P[new_var] = [(var1, var2)]
        variables.insert(0, new_var)  # inserts the new variable at the beginning
        # adds a new production that uses the current state and the remaining variables
        productions_copy[index] = (tuple(variables))
```
4. If the first element is a variable and second is a variable
 I add it as it is to the current production.
```angular2html
elif production[0] in self.VN and production[1] in self.VN:
                            productions_copy[index] = (production)
```
Then I continue with the case when the length of the production is more than 2. 
I take the first two variables from the production to work with them.
```angular2html
while len(variables) > 2:
  var1 = variables.pop(0)  # removes the first variable from the list
  var2 = variables.pop(0)  # removes the second variable from the list
```
First I check if the first variable(var1) is a terminal 
* if the first terminal is changed (in list_of_terminals_changed)
  * check if var2 is a variable
    * check if a variable for var1(changed) and var2 exists
      * if it exists, add it to the current production
      * if it does not exist, create a new variable for var1 and var2 and add it to the current production
  * check if var2 is a terminal
    * if var2 in list_of_terminals_changed
      * check if a variable for var1(changed) and var2(changed) exists
         * if it exists, add it to the current production
         * if it does not exist, create a new variable for var1 and var2 and add it to the current production
    

```angular2html
---
## Test
```python
```

## Results
![img.png](../images/lab4.png)
![img_1.png](../images/lab4_1.png)
![img_2.png](../images/lab4_2.png)
![img_3.png](../images/lab4_3.png)
![img_4.png](../images/lab4_4.png)
![img_5.png](../images/lab4_5.png)
![img_6.png](../images/lab4_6.png)
![img_7.png](../images/lab4_7.png)
![img_8.png](../images/lab4_8.png)
![img_9.png](../images/lab4_9.png)