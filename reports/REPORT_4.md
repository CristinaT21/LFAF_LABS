# Lab no. 4
## Topic: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Cristina Țărnă

----
## Objectives:
* Learn about Chomsky Normal Form (CNF).

* Get familiar with the approaches of normalizing a grammar.

* Implement a method for normalizing an input grammar by the rules of CNF.
    * The implementation needs to be encapsulated in a method with an appropriate signature (also 
  ideally in an appropriate class/type).
    * The implemented functionality needs to be executed and tested.
    * A BONUS point will be given for the student who will have unit tests that validate the functionality
  of the project.
    * Also, another BONUS point would be given if the student will make the aforementioned function to 
  accept any grammar, not only the one from the student's variant.

Variant 26

1. Eliminate epsilon productions.
2. Eliminate any renaming.
3. Eliminate inaccessible symbols.
4. Eliminate the non-productive symbols.
5. Obtain the Chomsky Normal Form.

G = (VN, VT,  P, S)
VN = {S, A, B, D } 
VT = {a, b, d} 

P = { S -> aBA ,
S -> AB ,
A -> d ,
A -> dS ,
A -> AbBA ,
A -> epsilon ,
B -> a ,
B -> aS ,
B -> A ,
D -> Aba 
}
## Implementation description

### Code snippets from Grammar class:
```
    def toChomskyNormalForm(self):
        self.eliminateEpsilonProductions()
        self.eliminateUnitProductions()
        self.eliminateInaccessibleSymbols()
        self.eliminateNonproductiveSymbols()
        self.eliminateLongProductions()
```
 
## Let's dive deeper.
### First step: Eliminate epsilon productions.
```
    def eliminateEpsilonProductions(self):
        # Find all nullable symbols
        nullable = set()
        for state in self.P:
            if 'epsilon' in self.P[state]:
                nullable.add(state)

        # Generate new productions without nullable symbols
        new_productions = {}
        for state in self.P:
            new_productions[state] = []
            for production in self.P[state]:
                if production == 'epsilon':
                    continue

                # Generate all combinations of production symbols
                combinations = [[]]
                for symbol in production:
                    if symbol in nullable:
                        # Add both possibilities (symbol present, symbol removed)
                        new_combinations = []
                        for comb in combinations:
                            new_combinations.append(comb + [symbol])
                            new_combinations.append(comb)
                        combinations = new_combinations
                    else:
                        # Add symbol to all combinations
                        for comb in combinations:
                            comb.append(symbol)
                print("start", combinations, 'end')
                # Add new productions to new_productions dict
                for comb in combinations:
                    if comb:
                        new_production = ''.join(comb)
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)

        # Add new productions generated by nullable symbols
        for state in self.P:
            for production in self.P[state]:
                for symbol in nullable:
                    if symbol in production and len(production) != 1:
                        new_production = production.replace(symbol, '')
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)

        # Update grammar with new productions
        self.P = new_productions
```
---
Here I find all nullable symbols.

```
# Find all nullable symbols
        nullable = set()
        for state in self.P:
            if 'epsilon' in self.P[state]:
                nullable.add(state)
```
---
Then I generate new productions without nullable symbols.

```
# Generate new productions without nullable symbols
        new_productions = {}
        for state in self.P:
            new_productions[state] = []
            for production in self.P[state]:
                if production == 'epsilon':
                    continue
```

---
Then I generate all combinations of production symbols.

```
  # Generate all combinations of production symbols
                combinations = [[]]
                for symbol in production:
                    if symbol in nullable:
                        # Add both possibilities (symbol present, symbol removed)
                        new_combinations = []
                        for comb in combinations:
                            new_combinations.append(comb + [symbol])
                            new_combinations.append(comb)
                        combinations = new_combinations
                    else:
                        # Add symbol to all combinations
                        for comb in combinations:
                            comb.append(symbol)
                print("start", combinations, 'end')
                # Add new productions to new_productions dict
                for comb in combinations:
                    if comb:
                        new_production = ''.join(comb)
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Then I add new productions generated by nullable symbols.

```
  # Add new productions generated by nullable symbols
        for state in self.P:
            for production in self.P[state]:
                for symbol in nullable:
                    if symbol in production and len(production) != 1:
                        new_production = production.replace(symbol, '')
                        if new_production not in new_productions[state]:
                            new_productions[state].append(new_production)
```
---
Finally, I update grammar with new productions.
```
# Update grammar with new productions
        self.P = new_productions
```

### Second step: Eliminate any renaming.
```
        def eliminateUnitProductions(self):
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = productions
        # Eliminate all unit productions except loops
        for state in self.P.keys():
            productions = new_productions[state]
            for production in productions:
                if len(production) == 1 and production.isupper():
                    # A unit production
                    unit_state = production
                    for unit_production in new_productions[unit_state]:
                        if unit_production != state and unit_production not in new_productions[state]:
                            new_productions[state].append(unit_production)
        # Eliminate loops
        for state in self.P.keys():
            productions = new_productions[state]
            if state in productions:
                new_productions[state].remove(state)
                for unit_production in new_productions[state]:
                    if unit_production != state and unit_production not in new_productions[state]:
                        new_productions[state].append(unit_production)
        # Remove all unit productions
        for state, productions in new_productions.items():
            new_productions[state] = [production for production in productions if
                                      len(production) > 1 or not production.isupper()]
        self.P = new_productions
```
---
Here I create a new dictionary with the same productions.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = productions
```

---
Here I eliminate all unit productions except loops. If a production is a unit production (from VN) , I add 
all productions of the unit state to the current state.
```
  # Eliminate all unit productions except loops
        for state in self.P.keys():
            productions = new_productions[state]
            for production in productions:
                if len(production) == 1 and production.isupper():
                    # A unit production
                    unit_state = production
                    for unit_production in new_productions[unit_state]:
                        if unit_production != state and unit_production not in new_productions[state]:
                            new_productions[state].append(unit_production)
```
---
Here I eliminate loops. If a state is in its productions, I remove it and add all other productions to the state.
```
  # Eliminate loops
        for state in self.P.keys():
            productions = new_productions[state]
            if state in productions:
                new_productions[state].remove(state)
                for unit_production in new_productions[state]:
                    if unit_production != state and unit_production not in new_productions[state]:
                        new_productions[state].append(unit_production)
```
---
Here I remove all unit productions.
 
``` 
# Remove all unit productions
        for state, productions in new_productions.items():
            new_productions[state] = [production for production in productions if
                                      len(production) > 1 or not production.isupper()]
```
---
Finally, I update the grammar with the new productions.
```
# Update the grammar with the new productions
        self.P = new_productions
```

### Third step: Eliminate inaccessible states.
```
        reachable = set()
        # Add the start symbol to the set of reachable symbols
        reachable.add(self.S)

        # Iterate through the productions and add any symbols that can be reached
        # from the start symbol
        while True:
            old_size = len(reachable)

            for state, productions in self.P.items():
                if state in reachable:
                    for production in productions:
                        for symbol in production:
                            if symbol in self.VN:
                                reachable.add(symbol)

            # Check if there are any new symbols that were added to the set of reachable symbols
            if len(reachable) == old_size:
                break

        # Find the set of inaccessible symbols
        inaccessible = set(self.VN) - reachable

        # Remove the productions involving inaccessible symbols
        new_productions = {}
        for state, productions in self.P.items():
            if state not in inaccessible:
                new_productions[state] = []
                for production in productions:
                    if not any(symbol in inaccessible for symbol in production):
                        new_productions[state].append(production)

        # Update the grammar with the new set of productions and non-terminals
        self.P = new_productions
        self.VN = reachable

        return Grammar(self.VN, self.VT, self.P, self.S)
```

---
First I create a set of reachable symbols and add the start symbol to it.
```
        reachable = set()
        # Add the start symbol to the set of reachable symbols
        reachable.add(self.S)
```
---
Then I iterate through the productions and add any symbols that can be reached from the start symbol.

```
        while True:
            old_size = len(reachable)

            for state, productions in self.P.items():
                if state in reachable:
                    for production in productions:
                        for symbol in production:
                            if symbol in self.VN:
                                reachable.add(symbol)
```
---
If there are no new symbols that were added to the set of reachable symbols, I break the loop.
```
            # Check if there are any new symbols that were added to the set of reachable symbols
            if len(reachable) == old_size:
                break
```
---
Then I find the set of inaccessible symbols.
```
        # Find the set of inaccessible symbols
        inaccessible = set(self.VN) - reachable
```
---
Finally, I remove the productions involving inaccessible symbols.
```
        # Remove the productions involving inaccessible symbols
        new_productions = {}
        for state, productions in self.P.items():
            if state not in inaccessible:
                new_productions[state] = []
                for production in productions:
                    if not any(symbol in inaccessible for symbol in production):
                        new_productions[state].append(production)
```
---
I update the grammar with the new set of productions and non-terminals.
```
        self.P = new_productions
        self.VN = reachable

        return Grammar(self.VN, self.VT, self.P, self.S)
```

### Fourth step: Eliminate non-productive states.
```
ef eliminateNonproductiveSymbols(self):
        productive = {self.S}
        changed = True
        while changed:
            changed = False
            for state, productions in self.P.items():
                for production in productions:
                    if all(s in productive for s in production):
                        if state not in productive:
                            productive.add(state)
                            changed = True
        nonproductive = set(self.VN) - productive
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = [p for p in productions if all(s not in nonproductive for s in p)]
        # Check if 'S' has an empty string production and remove it if it does
        if '' in new_productions[self.S]:
            new_productions[self.S].remove('')
        return Grammar(list(productive), self.VT, new_productions, self.S)
```
---
First I create a set of productive symbols and add the start symbol to it. Then I iterate through the 
productions and add any symbols that can be reached from the start symbol.
```
        productive = {self.S}
        changed = True
        while changed:
            changed = False
            for state, productions in self.P.items():
                for production in productions:
                    if all(s in productive for s in production):
                        if state not in productive:
                            productive.add(state)
                            changed = True
```
---
Then I find the set of non-productive symbols.
```
        nonproductive = set(self.VN) - productive
```
---
Finally, I remove the productions involving non-productive symbols.
```
        new_productions = {}
        for state, productions in self.P.items():
            new_productions[state] = [p for p in productions if all(s not in nonproductive for s in p)]
```
---
I check if 'S' has an empty string production and remove it if it does.
```
        # Check if 'S' has an empty string production and remove it if it does
        if '' in new_productions[self.S]:
            new_productions[self.S].remove('')
```
---
I update the grammar with the new set of productions and non-terminals.
```
        return Grammar(list(productive), self.VT, new_productions, self.S)
```

### Fifth step: Eliminate long productions.
```
      def eliminateLongProductions(self):
        new_grammar = self.clone()
        list_of_terminals_changed = []
        terminal_and_variable = {}
        for state in self.P:
            productions = self.P[state]
            for index, production in enumerate(productions):
                print(production, "production")
                print(len(production), "len")
                if len(production) == 2:
                    variables = list(production)
                    print(variables, "variables2")
                    print(len(variables), "len2")
                    if len(variables) == 2:
                        # check if the first variable is a terminal and the second is a variable
                        if production[0] in self.VT and production[1] in self.VN:
                            # check if the terminal has already been changed
                            if production[0] in list_of_terminals_changed:
                                new_grammar.P[state] = [(terminal_and_variable[production[0]], production[1])]
                                productions[index] = (new_grammar.P[state])
                            # if the terminal has not been changed, change it
                            else:
                                var1 = variables.pop(0)  # removes the first variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1)]
                                list_of_terminals_changed.append(var1)
                                terminal_and_variable[var1] = [new_var]
                                variables.insert(0, new_var)
                                productions[index] = (tuple(variables))
                                
                        # check if the first variable is a variable and the second is a terminal
                        elif production[0] in self.VN and production[1] in self.VT:
                            # check if the terminal has already been changed
                            if production[1] in list_of_terminals_changed:
                                new_grammar.P[index] = [(production[0], terminal_and_variable[production[1]])]
                                productions[index] = (new_grammar.P[state])
                            else:
                                var2 = variables.pop(1)  # removes the second variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [var2]
                                list_of_terminals_changed.append(var2)
                                variables.insert(0, new_var)
                                productions[index] = (tuple(variables))
                        elif production[0] in self.VT and production[1] in self.VT:
                            if production[0] in list_of_terminals_changed and production[1] in list_of_terminals_changed: # -----------------------------------------
                                new_grammar.P[index] = [(terminal_and_variable[production[0]], terminal_and_variable[production[1]])]
                                productions[index] = (new_grammar.P[index])
                            elif production[0] in list_of_terminals_changed and production[1] not in list_of_terminals_changed:
                                var2 = variables.pop(1)
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var2)]
                                list_of_terminals_changed.append(var2)
                                variables.insert(0, new_var)
                                new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
                                productions[index] = (tuple(variables))
                            elif production[0] not in list_of_terminals_changed and production[1] in list_of_terminals_changed:
                                var1 = variables.pop(0)
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1)]
                                list_of_terminals_changed.append(var1)
                                variables.insert(0, new_var)
                                new_grammar.P[index] = [(production[0], terminal_and_variable[production[1]])]
                                productions[index] = (tuple(variables))
                            else:
                                var1 = variables.pop(0)
                                var2 = variables.pop(0)  # removes the second variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1, var2)]
                                variables.insert(0, new_var)  # inserts the new variable at the beginning
                                # adds a new production that uses the current state and the remaining variables
                                productions[index] = (tuple(variables))

                        elif production[0] in self.VN and production[1] in self.VN:
                            break
                    else:
                        break
                elif len(production) > 2:
                    # Replace with new variables and productions
                    variables = list(production)
                    while len(variables) > 2:
                        print(variables,"variables")
                        print(len(variables), "len")
                        for i in range(len(variables)):
                            if production[i] in self.VT and production[i] not in list_of_terminals_changed:
                                var1 = variables.pop(i)
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1)]
                                list_of_terminals_changed.append(var1)
                                terminal_and_variable[var1] = [new_var]
                                print(terminal_and_variable[var1], "terminal_and_variable")

                                variables.insert(0, new_var)
                                productions[index] = (tuple(variables))
                            elif production[i] in self.VT and production[i] in list_of_terminals_changed:
                                new_grammar.P[state] = [(terminal_and_variable[production[i]])]
                                productions[index] = (new_grammar.P[state])
                            # else:
                            #     new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
                        var1 = variables.pop(0)  # removes the first variable from the list
                        var2 = variables.pop(0)  # removes the second variable from the list
                        new_var = new_grammar.getNewVariable()
                        new_grammar.VN.add(new_var)
                        new_grammar.P[new_var] = [(var1, var2)]
                        variables.insert(0, new_var)  # inserts the new variable at the beginning
                    # adds a new production that uses the current state and the remaining variables
                    productions[index] = (tuple(variables))
                else:
                    productions[index] = production  # add the production as is
            new_grammar.P[state] = productions  # Update the grammar with the new productions
            print(variables, "variables")
        return new_grammar
```
---
Here I am trying to add the new variables to the list of terminals changed so that I can check if the
terminal has already been changed. I am also trying to add the new variables to the dictionary of
terminals and variables so that I can use it later on.
```
        new_grammar = self.clone()
        list_of_terminals_changed = []
        terminal_and_variable = {}
```
---
Here I am trying to check if the first variable is a terminal and the second is a variable. If it is
then I am trying to check if the terminal has already been changed. If it has then I am trying to
change the production to the new variable. If it hasn't then I am trying to change the production to
the new variable and add the new variable to the list of terminals changed.
```
        elif production[0] in self.VT and production[1] in self.VN:
                            # check if the terminal has already been changed
                            if production[0] in list_of_terminals_changed:
                                new_grammar.P[index] = [(terminal_and_variable[production[0]], production[1])]
                                productions[index] = (new_grammar.P[index])
                            else:
                                var1 = variables.pop(0)  # removes the first variable from the list
                                new_var = new_grammar.getNewVariable()
                                new_grammar.VN.add(new_var)
                                new_grammar.P[new_var] = [(var1)]
                                list_of_terminals_changed.append(var1)
                                terminal_and_variable[var1] = [new_var]
                                variables.insert(0, new_var)
                                productions[index] = (tuple(variables))
```
---
## Test
```python
```

## Results
#####![img.png](../images/lab3_1.png)